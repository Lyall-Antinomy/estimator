// estimator-model.ts

/* ------------------------------------------------------------
   Core enums
------------------------------------------------------------ */

export type CurrencyCode = 'EUR' | 'USD' | 'GBP' | string;

export type ResolutionLevel = 1 | 2 | 3 | 4 | 5 | 6 | 7;

export type Confidence = 'high' | 'medium' | 'low';

export type LockState = 'spec' | 'truth';

/**
 * Cohesion tags drive the "Consistency Pass" (soft floor weapon).
 * - core: foundation + key templates (experience-defining)
 * - utility: pages like contact/privacy (can be simpler but bounded)
 * - optional: truly optional/extra work
 */
export type CohesionTag = 'core' | 'utility' | 'optional';

/**
 * Line item category types. These map to how price is computed.
 */
export type ItemType =
  | 'foundation' // "System Setup"
  | 'template'   // "Page Type"
  | 'instance'   // "Pages" (count + complexity)
  | 'extra'      // integrations, content migration, motion, etc.
  | 'auto';      // generated by the engine e.g. "Consistency Pass"


/* ------------------------------------------------------------
   Pricing configuration
------------------------------------------------------------ */

export type ResolutionCurve = Record<ResolutionLevel, number>;
// Example curve: {1:0.5,2:0.75,3:1,4:1.35,5:1.8,6:2.5,7:3.3}

export type ConfidenceBuffer = Record<Confidence, number>;
// Example: {high:0, medium:0.08, low:0.18}

export type ComplexityBand = 'simple' | 'standard' | 'complex';

export type ComplexityMultiplier = Record<ComplexityBand, number>;
// Example: {simple:0.75, standard:1.0, complex:1.35}

/**
 * Unit rates let you keep Base Cost non-arbitrary without showing "days".
 * Units are internal. Clients never see these.
 */
export type UnitType =
  | 'system'       // foundation units
  | 'template'     // template/page-type units
  | 'pageInstance' // per page instance units
  | 'integration'  // Shopify/CMS/auth/etc.
  | 'content'      // migration / population
  | 'motion'       // motion system / animations
  | 'qa';          // QA / accessibility / perf pass

export type UnitRateTable = Record<UnitType, number>; // currency per unit

export interface ClientPreset {
  id: string;
  label: string;

  currency: CurrencyCode;

  // pricing knobs
  pmPercent: number; // e.g. 0.15
  resolutionCurve: ResolutionCurve;
  confidenceBuffer: ConfidenceBuffer;

  complexityMultiplier: ComplexityMultiplier;

  // internal unit costs
  unitRates: UnitRateTable;

  // cohesion weapon knobs
  cohesion: {
    enabled: boolean;

    /**
     * Floors are derived from max core resolution:
     * - coreFloorDelta: how far below max core you allow other core items to drop before debt
     * - utilityFloorDelta: how far below max core you allow utility items to drop before debt
     *
     * Example:
     * max core is 6 (Flagship)
     * core floor = max(3, 6 - 2) = 4 (Polished)
     * utility floor = max(2, 6 - 4) = 2 (Draft)
     */
    coreFloorDelta: number;    // e.g. 2
    utilityFloorDelta: number; // e.g. 4

    // hard minimums (regardless of max core)
    minCoreFloor: ResolutionLevel;    // e.g. 3
    minUtilityFloor: ResolutionLevel; // e.g. 2

    /**
     * Debt factor: % of the item's *base* (pre-PM) per notch below recommended floor.
     * This turns incoherence into a priced decision.
     */
    debtFactorPerNotch: number; // e.g. 0.12 (12% per notch)

    /**
     * Where to price the debt from:
     * - 'itemBase': use the affected item's computed base (sans PM)
     * - 'estimateTruth': use a % of the estimate truth subtotal (more aggressive)
     */
    debtPricingMode: 'itemBase' | 'estimateTruth';

    /**
     * If debtPricingMode is estimateTruth, apply this fraction per notch (small).
     * e.g. 0.02 => 2% of estimate truth per notch mismatch aggregated.
     */
    estimateTruthDebtFactorPerNotch?: number;
  };
}


/* ------------------------------------------------------------
   Estimate + line items
------------------------------------------------------------ */

export interface EstimateMeta {
  id: string;
  title: string;         // e.g. "new—land marketing site estimate"
  clientName: string;
  createdAtISO: string;  // ISO string
  updatedAtISO: string;
  currency: CurrencyCode;

  validityDays: number;  // e.g. 14
  taxPercent?: number;   // optional VAT etc.
}

export interface LineItemBase {
  id: string;

  type: ItemType;
  cohesionTag: CohesionTag;

  title: string;
  description?: string;

  // Truth vs Spec
  lockState: LockState;

  // price drivers
  resolution: ResolutionLevel;
  confidence: Confidence;

  // Optional: a guardrail for “can’t go below Draft without becoming something else”
  minResolution?: ResolutionLevel;

  // Optional: auto-rename rules when resolution drops below thresholds (client-facing truth)
  // Implemented as a mapping from resolution max to replacement title/subtitle.
  // Example: {2: "Landing page prototype", 1: "Landing page concept"}
  renameWhenAtOrBelow?: Partial<Record<ResolutionLevel, { title: string; description?: string }>>;

  // Studio-only
  notesInternal?: string;

  // Client-visible comment thread (simple MVP)
  clientNote?: string;
}

export interface UnitizedPricing {
  unitType: UnitType;
  units: number; // internal unit count, can be fractional
}

/**
 * Foundation + Template + Extra:
 * computed from internal unitized pricing.
 */
export interface ComputedItem extends LineItemBase {
  type: 'foundation' | 'template' | 'extra';
  pricing: UnitizedPricing[];
}

/**
 * Instances:
 * count + complexity band + per-page unit.
 */
export interface InstanceItem extends LineItemBase {
  type: 'instance';
  count: number;
  complexity: ComplexityBand;

  pricing: {
    unitType: 'pageInstance';
    unitsPerInstance: number;
  };
}

/**
 * Auto items are generated; typically locked as Spec until user accepts.
 */
export interface AutoItem extends LineItemBase {
  type: 'auto';
  autoKind: 'consistencyPass';

  // reference back to what caused it (useful for explaining)
  derivedFrom: {
    maxCoreResolution: ResolutionLevel;
    coreFloor: ResolutionLevel;
    utilityFloor: ResolutionLevel;
    mismatches: Array<{
      itemId: string;
      itemTitle: string;
      itemTag: CohesionTag;
      itemResolution: ResolutionLevel;
      recommendedFloor: ResolutionLevel;
      notchesBelow: number;
    }>;
  };

  // priced as a single line item (unit-based or direct)
  pricing: {
    mode: 'unitized' | 'direct';
    unitized?: UnitizedPricing[];
    directAmount?: number; // currency amount, pre-PM
  };
}

export type LineItem = ComputedItem | InstanceItem | AutoItem;

export interface Estimate {
  meta: EstimateMeta;

  presetId: string; // links to ClientPreset
  items: LineItem[];

  // Optional revisioning in v1 (can skip persistence initially)
  revision?: {
    number: number;
    parentEstimateId?: string;
  };
}


/* ------------------------------------------------------------
   Audit log (optional but powerful)
------------------------------------------------------------ */

export interface ChangeEvent {
  id: string;
  atISO: string;
  actor: 'studio' | 'client';
  itemId?: string;
  field: string; // e.g. "resolution", "count", "lockState"
  from: unknown;
  to: unknown;
}

export interface EstimateWithLog extends Estimate {
  changeLog: ChangeEvent[];
}


/* ------------------------------------------------------------
   Price computation outputs
------------------------------------------------------------ */

export interface ItemPriceBreakdown {
  itemId: string;

  // Pre-PM amounts (so you can show PM as a separate line in UI/PDF if desired)
  basePrePM: number;

  // PM applied as a multiplier
  pmAmount: number;

  // Final line total before tax
  total: number;

  // debugging / explanation
  drivers: {
    resolution: ResolutionLevel;
    resolutionMultiplier: number;
    confidence: Confidence;
    confidenceMultiplier: number;
    complexity?: ComplexityBand;
    complexityMultiplier?: number;
    unitCostSum: number;
  };
}

export interface EstimateTotals {
  truthSubtotal: number;
  specSubtotal: number;

  truthItems: ItemPriceBreakdown[];
  specItems: ItemPriceBreakdown[];

  pmTotalTruth: number;
  pmTotalSpec: number;

  taxAmountTruth?: number;
  taxAmountSpec?: number;

  grandTotalTruth: number;
  grandTotalSpec: number;
}


/* ------------------------------------------------------------
   Compute functions (pure)
------------------------------------------------------------ */

export function resolveRename(item: LineItem): Pick<LineItem, 'title' | 'description'> {
  const rules = item.renameWhenAtOrBelow;
  if (!rules) return { title: item.title, description: item.description };

  // Find the highest threshold >= current resolution? Actually rule is "at or below X"
  // so we should pick the closest rule with key >= current resolution (lower numbers),
  // i.e. if resolution=2 and rules[2] exists, apply it; else check 3..? No.
  // We'll scan down from current resolution to 1.
  for (let lvl = item.resolution; lvl >= 1; lvl--) {
    const r = rules[lvl as ResolutionLevel];
    if (r) return { title: r.title, description: r.description ?? item.description };
  }
  return { title: item.title, description: item.description };
}

export function computeItemBasePrePM(item: LineItem, preset: ClientPreset): number {
  const resMult = preset.resolutionCurve[item.resolution];
  const confMult = 1 + (preset.confidenceBuffer[item.confidence] ?? 0);

  let unitCostSum = 0;

  if (item.type === 'instance') {
    const cxMult = preset.complexityMultiplier[item.complexity];
    const per = item.pricing.unitsPerInstance * preset.unitRates.pageInstance;
    unitCostSum = item.count * per * cxMult;
  } else if (item.type === 'auto') {
    if (item.pricing.mode === 'direct') {
      unitCostSum = item.pricing.directAmount ?? 0;
    } else {
      unitCostSum = (item.pricing.unitized ?? []).reduce((sum, p) => {
        return sum + p.units * preset.unitRates[p.unitType];
      }, 0);
    }
  } else {
    unitCostSum = item.pricing.reduce((sum, p) => sum + p.units * preset.unitRates[p.unitType], 0);
  }

  // base is units * resolution curve * confidence multiplier
  return unitCostSum * resMult * confMult;
}

export function computeItemTotal(item: LineItem, preset: ClientPreset): ItemPriceBreakdown {
  const basePrePM = computeItemBasePrePM(item, preset);
  const pmAmount = basePrePM * preset.pmPercent;
  const total = basePrePM + pmAmount;

  const resMult = preset.resolutionCurve[item.resolution];
  const confMult = 1 + (preset.confidenceBuffer[item.confidence] ?? 0);

  let cxMult: number | undefined;
  if (item.type === 'instance') cxMult = preset.complexityMultiplier[item.complexity];

  // unitCostSum (pre multipliers) for explainability
  let unitCostSum = 0;
  if (item.type === 'instance') {
    const per = item.pricing.unitsPerInstance * preset.unitRates.pageInstance;
    unitCostSum = item.count * per * (cxMult ?? 1);
  } else if (item.type === 'auto') {
    unitCostSum =
      item.pricing.mode === 'direct'
        ? (item.pricing.directAmount ?? 0)
        : (item.pricing.unitized ?? []).reduce((sum, p) => sum + p.units * preset.unitRates[p.unitType], 0);
  } else {
    unitCostSum = item.pricing.reduce((sum, p) => sum + p.units * preset.unitRates[p.unitType], 0);
  }

  return {
    itemId: item.id,
    basePrePM,
    pmAmount,
    total,
    drivers: {
      resolution: item.resolution,
      resolutionMultiplier: resMult,
      confidence: item.confidence,
      confidenceMultiplier: confMult,
      complexity: item.type === 'instance' ? item.complexity : undefined,
      complexityMultiplier: cxMult,
      unitCostSum,
    },
  };
}

export function computeTotals(estimate: Estimate, preset: ClientPreset): EstimateTotals {
  const truthItems: ItemPriceBreakdown[] = [];
  const specItems: ItemPriceBreakdown[] = [];

  for (const item of estimate.items) {
    const breakdown = computeItemTotal(item, preset);
    if (item.lockState === 'truth') truthItems.push(breakdown);
    else specItems.push(breakdown);
  }

  const truthSubtotal = truthItems.reduce((s, b) => s + b.total, 0);
  const specSubtotal = specItems.reduce((s, b) => s + b.total, 0);

  const pmTotalTruth = truthItems.reduce((s, b) => s + b.pmAmount, 0);
  const pmTotalSpec = specItems.reduce((s, b) => s + b.pmAmount, 0);

  const taxPct = estimate.meta.taxPercent ?? 0;
  const taxAmountTruth = taxPct > 0 ? truthSubtotal * taxPct : undefined;
  const taxAmountSpec = taxPct > 0 ? specSubtotal * taxPct : undefined;

  const grandTotalTruth = truthSubtotal + (taxAmountTruth ?? 0);
  const grandTotalSpec = specSubtotal + (taxAmountSpec ?? 0);

  return {
    truthSubtotal,
    specSubtotal,
    truthItems,
    specItems,
    pmTotalTruth,
    pmTotalSpec,
    taxAmountTruth,
    taxAmountSpec,
    grandTotalTruth,
    grandTotalSpec,
  };
}


/* ------------------------------------------------------------
   Cohesion engine: generate Consistency Pass (soft weapon)
------------------------------------------------------------ */

export function computeRecommendedFloors(
  items: LineItem[],
  preset: ClientPreset
): { maxCoreResolution: ResolutionLevel; coreFloor: ResolutionLevel; utilityFloor: ResolutionLevel } {
  const coreItems = items.filter((i) => i.cohesionTag === 'core' && i.type !== 'auto');

  // reduce as number (prevents overload confusion)
  const maxCore = coreItems.reduce<number>((m, i) => {
    return Math.max(m, i.resolution);
  }, 0);

  // default to 3 if there are no core items
  const maxCoreResolution: ResolutionLevel = (maxCore === 0 ? 3 : maxCore) as ResolutionLevel;

  const coreFloor = Math.max(
    preset.cohesion.minCoreFloor,
    (maxCoreResolution - preset.cohesion.coreFloorDelta) as ResolutionLevel
  ) as ResolutionLevel;

  const utilityFloor = Math.max(
    preset.cohesion.minUtilityFloor,
    (maxCoreResolution - preset.cohesion.utilityFloorDelta) as ResolutionLevel
  ) as ResolutionLevel;

  return { maxCoreResolution, coreFloor, utilityFloor };
}

/**
 * Builds/updates a single auto line item: "Consistency Pass"
 * - Always lockState = 'spec' by default (studio can lock it later)
 * - If no mismatches, returns null (remove item if present)
 */
export function buildConsistencyPass(
  estimate: Estimate,
  preset: ClientPreset
): AutoItem | null {
  if (!preset.cohesion.enabled) return null;

  const { maxCoreResolution, coreFloor, utilityFloor } = computeRecommendedFloors(estimate.items, preset);

  const mismatches: AutoItem['derivedFrom']['mismatches'] = [];

  for (const item of estimate.items) {
    if (item.type === 'auto') continue;

    const recommendedFloor =
      item.cohesionTag === 'core' ? coreFloor
      : item.cohesionTag === 'utility' ? utilityFloor
      : 1;

    if (item.resolution < recommendedFloor) {
      mismatches.push({
        itemId: item.id,
        itemTitle: item.title,
        itemTag: item.cohesionTag,
        itemResolution: item.resolution,
        recommendedFloor,
        notchesBelow: recommendedFloor - item.resolution,
      });
    }
  }

  if (mismatches.length === 0) return null;

  // Price the debt
  let directAmountPrePM = 0;

  if (preset.cohesion.debtPricingMode === 'itemBase') {
    // sum item base (pre-PM) * debtFactorPerNotch * notchesBelow
    for (const m of mismatches) {
      const item = estimate.items.find(i => i.id === m.itemId);
      if (!item || item.type === 'auto') continue;

      const basePrePM = computeItemBasePrePM(item, preset);
      directAmountPrePM += basePrePM * preset.cohesion.debtFactorPerNotch * m.notchesBelow;
    }
  } else {
    // estimateTruth mode: apply small % of truth subtotal per notch
    const totals = computeTotals(estimate, preset);
    const factor = preset.cohesion.estimateTruthDebtFactorPerNotch ?? 0.02;
    const notchSum = mismatches.reduce((s, m) => s + m.notchesBelow, 0);
    directAmountPrePM = totals.truthSubtotal * factor * notchSum;
  }

  const auto: AutoItem = {
    id: 'auto-consistency-pass',
    type: 'auto',
    autoKind: 'consistencyPass',
    cohesionTag: 'core', // treat as core: it preserves experience coherence
    title: 'Consistency Pass',
    description:
      'Aligns finish level across pages and templates to avoid a fragmented experience.',
    lockState: 'spec',
    resolution: 3, // keep Standard (acts like a neutral wrapper)
    confidence: 'high',

    derivedFrom: {
      maxCoreResolution,
      coreFloor,
      utilityFloor,
      mismatches,
    },

    pricing: {
      mode: 'direct',
      directAmount: Math.max(0, directAmountPrePM),
    },
  };

  return auto;
}

/**
 * Utility helper: apply cohesion pass to an estimate (add/update/remove auto item).
 */
export function withAutoItems(estimate: Estimate, preset: ClientPreset): Estimate {
  const existing = estimate.items.filter(i => !(i.type === 'auto' && i.autoKind === 'consistencyPass'));
  const pass = buildConsistencyPass({ ...estimate, items: existing }, preset);

  return {
    ...estimate,
    items: pass ? [...existing, pass] : existing,
  };
}